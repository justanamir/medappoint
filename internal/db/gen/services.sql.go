// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: services.sql

package gen

import (
	"context"
)

const getService = `-- name: GetService :one
SELECT id, clinic_id, name, description, duration_min, created_at, updated_at
FROM services
WHERE id = $1
`

func (q *Queries) GetService(ctx context.Context, id int64) (Service, error) {
	row := q.db.QueryRow(ctx, getService, id)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.ClinicID,
		&i.Name,
		&i.Description,
		&i.DurationMin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listServices = `-- name: ListServices :many
SELECT
  s.id,
  s.clinic_id,
  s.name,
  s.description,
  s.duration_min,
  c.name     AS clinic_name,
  c.timezone AS clinic_timezone
FROM services s
JOIN clinics  c ON c.id = s.clinic_id
ORDER BY s.id
`

type ListServicesRow struct {
	ID             int64   `json:"id"`
	ClinicID       int64   `json:"clinic_id"`
	Name           string  `json:"name"`
	Description    *string `json:"description"`
	DurationMin    int32   `json:"duration_min"`
	ClinicName     string  `json:"clinic_name"`
	ClinicTimezone string  `json:"clinic_timezone"`
}

func (q *Queries) ListServices(ctx context.Context) ([]ListServicesRow, error) {
	rows, err := q.db.Query(ctx, listServices)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListServicesRow
	for rows.Next() {
		var i ListServicesRow
		if err := rows.Scan(
			&i.ID,
			&i.ClinicID,
			&i.Name,
			&i.Description,
			&i.DurationMin,
			&i.ClinicName,
			&i.ClinicTimezone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
