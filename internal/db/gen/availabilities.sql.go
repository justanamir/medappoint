// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: availabilities.sql

package gen

import (
	"context"
)

const listAvailabilitiesByProvider = `-- name: ListAvailabilitiesByProvider :many
SELECT
  a.id,
  a.provider_id,
  a.weekday,
  a.start_hhmm,
  a.end_hhmm,
  p.full_name AS provider_name
FROM availabilities a
JOIN providers p ON p.id = a.provider_id
WHERE a.provider_id = $1
ORDER BY a.weekday
`

type ListAvailabilitiesByProviderRow struct {
	ID           int64  `json:"id"`
	ProviderID   int64  `json:"provider_id"`
	Weekday      int32  `json:"weekday"`
	StartHhmm    string `json:"start_hhmm"`
	EndHhmm      string `json:"end_hhmm"`
	ProviderName string `json:"provider_name"`
}

func (q *Queries) ListAvailabilitiesByProvider(ctx context.Context, providerID int64) ([]ListAvailabilitiesByProviderRow, error) {
	rows, err := q.db.Query(ctx, listAvailabilitiesByProvider, providerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAvailabilitiesByProviderRow
	for rows.Next() {
		var i ListAvailabilitiesByProviderRow
		if err := rows.Scan(
			&i.ID,
			&i.ProviderID,
			&i.Weekday,
			&i.StartHhmm,
			&i.EndHhmm,
			&i.ProviderName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
